#!/usr/bin/perl -w
use strict;
package bmfont;
use tmstub;
use bits;

=for docs

Bitmap font definitions with an optional ASCII text human-readable format.
Variable width fonts with fixed width storage (in C/C++).

C Source code generation. Currently supports 16-bit storage. 
Text kerning.

bitmaps: rectangular, zeroes and ones
glyphs: belonging to a font
internal font formats: height, encoded bitmap and width tables 

=cut

our @EXPORT    = qw(camel);    # Symbols to be exported by default



sub kern_bitmaps {
    my $font = shift;
    my $txt = shift;
    my $out;
    # parse text into directives and text
    $txt =~ tr/[]/\n\n/;
    my @segs = split /^/, $txt;
    my $procchars = 1;
    my $kern = 0;
    foreach(@segs){
        chomp;
        if($procchars){
            #t "CHARS: $_";
            my @ca = split //, $_;
            foreach(@ca){
                # append this glyph to bitmap test at this offset
                # normal offset is 2, if a kerning saving is to be made then it will be 2-k
                my $g = fullfont_get_glyph($font, $_);
                die "no glyph for char '$_' " unless $g;
                if(not defined $out){
                    $out = $g;
                } else {
                    $out = append_glyph($out, $g, $kern);
                }
                $kern = 0;
            }
        } else {
            #t "KERN: $_";
            $kern = $_;
        }
        # alternate between kern control and character output...
        $procchars = not $procchars;
    }
    return $out;
}

sub append_glyph {
    my ($bm, $g, $kern) = @_;
    my @bm = split /^/, $bm;
    my @gm = split /^/, $g;
    if(scalar(@bm) != 16){
        t "bitmap not 16 rows";
        t "debug context here";
    }
    die "bitmap not 16 rows" unless scalar(@bm) == 16; 
    die "glyph not 16 rows" unless scalar(@gm) == 16; 
    my @a;
    for(my $i = 0; $i < 16; $i++){
        push @a, binpaste($bm[$i], $gm[$i], $kern);
    }
    return join "\n", @a;
}

## Add a new bitmap onto the end of this bitmap row string with a kerning 
## adjustment. The bitmaps can overlap.
## An additional 2 pixel spacing is applied.
## In this function, the hash and period characters are one and zero. 
sub binpaste {
    my ($b1, $b2, $kern) = @_;
    chomp $b1;
    chomp $b2;
    my $inter_char_gap = 2;
#    if($kern == 0){
#        return $b1 . ".." . $b2;
#    }
    my $w1 = length $b1;
    my $w2 = length $b2;
    # pad out the first bitmap to 
    my $newlen = $w1 + $w2 + $inter_char_gap - $kern;
    my $extend = "." x ($newlen - $w1);
    my $out = $b1 . $extend;
    # now fill in the second bitmap
    # starting from the start of the new bitmap at $newlen - $w2
    for(my $i = 0; $i < $w2; $i++){
        my $pos = $newlen - $w2 + $i;
        my $pix = substr($b2, $i, 1);
        if($pix eq '#'){
            substr($out, $pos, 1) = $pix;
        }
    }
    return $out;    
}

sub kern_text {
    my $font = shift;
    my $txt = shift;
    my $out = "";
    my @chars = split //, $txt;
    for(my $i = 0; $i < $#chars; $i++){
        my($c1, $c2) = ($chars[$i], $chars[$i+1]);
        my $val = kern_pair($font, $c1, $c2);
        # $val = 2-$val;
        $out .= $c1 if $i == 0;
        $out .= "[$val]" if $val != 0;
        $out .= $c2;
    }
    $out.="\n";
    return $out;    
}

sub kern_pair {
    my($font, $c1, $c2) = @_;
    # deal with space
    if(($c1 eq " ") or ($c2 eq " ")){
        t "never kern whitespace";
        return 0;
    }
    
    # get font glyphs for c1 and c2
    my $bm1 = fullfont_get_glyph($font, $c1);
    my $bm2 = fullfont_get_glyph($font, $c2);
    die unless $bm1;
    die unless $bm2;
    my @bm1 = map{ chomp; $_;} split /^/, $bm1;
    my @bm2 = map{ chomp; $_;} split /^/, $bm2;
    # get widths
    my $w1 = length($bm1[0]);
    my $w2 = length($bm2[0]);
    my $k;
    for(my $r = 0; $r < 16; $r++){
        # kern row
        my $p1 = $bm1[$r];
        my $p2 = $bm2[$r];
        # get rightmost pixel of p1 and leftmost pixel of p2
        my $i1 = rindex($p1, "#");
        my $i2 = index($p2, "#");
        # min position for first pixel of c2
        
        # gap profiles for each side
        my $g1 = $w1 - ($i1 + 1);
        my $g2 = ($i2 == -1) ? $w2 : $i2;
        my $gt = $g1 + $g2;
        
        #t "$p1 -- $p2 === $i1 \t $i2 \t $w1 \t $w2 \t $g1 -- $g2 :: $gt";
        t "$p1 -- $p2 === $g1 -- $g2 :: $gt";
        if(! defined $k){ $k = $gt }
        if($gt < $k){ $k = $gt}
    }
    # limit to 50% overlap of either glyph?
    my $kmax50 = int(min($w1/2, $w2/2));
    my $kmax50c = int($w1/2 + $w2/2);
    t "computed max kern = $k  :: trim to $kmax50 or $kmax50c";
    return $k;
}

sub min {
    my($i, $j) = @_;
    return $i < $j ? $i : $j;
}

sub max {
    my($i, $j) = @_;
    return $i > $j ? $i : $j;
}

sub fullfont_get_glyph {
    my($font, $c) = @_;
    my $k = sprintf( "ASCII %03d", ord($c) );
    return $font->{bms}->{$k};
}

sub generate_source {
    my $x = shift;

    #            gaps   => $gaps,
    #            start  => $start,
    #            end    => $end,
    #            count  => $count,
    #            hexa    => $hexes,
    #            widths => $widths,
    #            info   => $infos,
    #            nice   => $nices
    #        };
    my $count  = $x->{count};
    my $widths = $x->{widths};
    my $infos  = $x->{info};
    my $nices  = $x->{nice};
    my $hexes  = $x->{hexa};

    my @ks  = sort keys %$widths;
    my $src = "";
    $src .= "    // FONT INFO: -\n";
    foreach (@ks) {
        $src .= $infos->{$_} . "\n";
    }
    $src .= "\n\n";

    # character bitmap widths table...
    $src .= "uint8_t charfontwidths[$count] = {\n";
    foreach (@ks) {
        $src .= $widths->{$_} . ", ";
    }
    $src .= "\n};\n";

    # character bitmap table...
    $src .= "uint16_t charfontdata[$count * 16] = {\n";
    foreach (@ks) {
        $src .= $infos->{$_} . "\n";
        $src .= $nices->{$_} . "\n";
        $src .= "    " . $hexes->{$_} . "\n";
    }
    $src .= "};\n\n";
    return $src;
}

# Rip through simple font and calculate width. Optionally add
# nice human-readable bitmap comment with tr/01/.#/;
# 16-bit hex definitions for adding to font data array
# widths array, etc.
sub font_study {
    my $f = shift or die;
    die unless ref($f) eq 'HASH';
    my $gethex = shift;

    # font keys must be contiguous
    # an initial offset is allowed
    my $start  = undef;
    my $prev   = undef;
    my $gaps   = "";
    my $count  = 0;
    my $hexes  = {};
    my $widths = {};
    my $nices  = {};
    my $infos  = {};
    my $bms  = {};
    foreach ( sort keys %$f ) {

        if ( !/^ASCII (\d+)$/ ) {
            t "ERROR: bad glyph name " . d($_);
            next;
        }
        $count++;
        my $num = $1 + 0;
        if ( not defined $start ) {
            $start = $num;
            $prev  = $num;
        } elsif ( $num != $prev + 1 ) {
            #t "ERROR: gap between $prev and $num";
            $gaps .= "gap between $prev and $num, ";
        }

        # deal with bitmap
        my $bm = $f->{$_};
        my ( $height, $min, $max, $hex16 ) = bitmap_geom( $bm, 16 );
        die "ragged $_" unless $min == $max;
        die "bad bitmap height $_" unless $height == 16;
        if ($gethex) {
            $hexes->{$_}  = $hex16;
            $widths->{$_} = $max;
            my $n = $bm;
            $n =~ tr/01/.#/;
            $bms->{$_} = $n;
            $n =~ s/^/    \/\/ /gm;
            $nices->{$_} = $n;
            my $info =
              sprintf "    // ASCII char %3d, 0x%02X  = '%s' width: %2d ", $num,
              $num, chr($num), $max;
            $infos->{$_} = $info;
        }

        # move on
        $prev = $num;
    }
    my $end = $prev;
    if ($gethex) {
        return {
            gaps   => $gaps,
            start  => $start,
            end    => $end,
            count  => $count,
            hexa   => $hexes,
            widths => $widths,
            info   => $infos,
            nice   => $nices,
            bms   => $bms
        };
    } else {
        return {
            gaps  => $gaps,
            start => $start,
            end   => $end,
            count => $count
        };
    }
}

# validate an ascii bitmap of 0 and 1 chars. Get geometry and a 16-bit version.
sub bitmap_geom {
    my ( $bm, $conv_16bit ) = @_;
    my @rows = split /^/, $bm;
    my @conv;
    my ( $height, $min, $max ) = (0);
    foreach (@rows) {

        # trim...
        chomp;
        s/^\s+//;
        s/\s+$//;
        if ( !/^[01]+$/ ) {
            die "bad bitmap data";
        }
        $height++;
        my $len = length;
        $min = $len unless defined $min;
        $max = $len unless defined $max;
        $max = $len if $len > $max;
        $min = $len if $len < $min;
        if ($conv_16bit) {
            push @conv, sprintf( "0x%04X,", bin2dec( binpad16($_) ) );
        }
    }
    my $conv = join "", @conv;
    return ( $height, $min, $max, $conv );
}

sub merge_simple_fonts {
    my ( $f1, $f2 ) = @_;
    die unless ref($f1) eq 'HASH';
    die unless ref($f2) eq 'HASH';
    my %merged = ( %$f1, %$f2 );
    return \%merged;
}


sub trimmer {
    my $t = shift;
    my @r = split /^/, $t;
    @r = map { chomp; s/^\s+//; s/\s+$//; $_ } @r;
    $t = join "\n", @r;
    return $t;
}
    
## accept text - emit font
## The font is in a format with bitmaps and directives separated by one or more
## blank lines. The "ASCII <n>" directives say which ASCII char the following
## bitmap represents. Absence of an ASCII directive implies that the next bitmap
## follows on from the previous.
##
## This data has been exported from a spreadsheet using OpenOffice CSV export
## with space as a separator.
## As such there are padded fields where there might otherwise be "blank" lines.
## We run the text through a trimmer to remedy this.
sub simple_font_interp {
    my $t = shift;
    # trim lines...
    $t = trimmer($t);
    # replace multiple blank lines with single blanks...
    $t =~ s/\n\n\n+/\n\n/g;
    # get as a nice list...
    my @aa = split "\n\n", $t;
    @aa = grep { chomp; s/^\s+//; s/\s+$//; length; } @aa;

    #t d \@aa;
    my %f;
    my $c = ord("@");
    foreach (@aa) {
        if (/^ASCII (\d+)/) {
            $c = $1;

            #t "ascii change to $c = ".chr($c);
            next;
        }
        if ( !/^[01\s]+$/ ) {
            t "comment? " . d($_);
            next;
        }

        #t "ascii val for $c = ".chr($c);
        my $k = sprintf( "ASCII %03d", $c );

        # remove spaces from bitmap lines...
        tr/ /v/;
        s/v//gm;
        $f{$k} = $_;
        $c++;
    }
    return \%f;
}

## pad out the given binary number to 16 bits wide
sub binpad16 {
    return substr( shift . "0" x 16, 0, 16 );
}
## get decimal value of given binary string (max 32 bits)
sub bin2dec {
    return unpack( "N", pack( "B32", substr( "0" x 32 . shift, -32 ) ) );
}


## returns a hashref of ASCII %03d => "binary data"
sub proc_default_font {
    my $t = shift;
    return unless $t;

    # when processing LH font $t =~ s/\n\n\n+/\n\n/g;

    # get as a nice list - we expect blank lines between characters...
    my @aa = split "\n\n", $t;

    # the default font has extra directives to indicate the ASCII values
    # the spreadsheet font has extra directives ASCII nn comment
    my %font = (@aa);

    # t d \%font;

    # when processing font without 3char ascii code...
    #    my %f2;
    #    foreach my $k (keys %font){
    #        my $v = $font{$k};
    #        $k=~ /^ASCII (\d+)/;
    #        $k = sprintf("ASCII %03d", $1);
    #        $f2{$k} = $v;
    #    }
    #    %font = %f2;

    # self output
    #    foreach my $k (sort keys %font){
    #        my $v = $font{$k};
    #        t "$k\n\n$v\n";
    #    }

    #    foreach (@aa) {
    #
    #        # when translating LH font...
    #        #        if(/^(\d+),(\d+),(\d+),"(.)"/){
    #        #            t "ASCII $1\n";
    #        #            next;
    #        #        }
    #        if (/^ASCII (\d+)/) {
    #            t $_;
    #            t "";
    #            next;
    #        }
    #        t $_;
    #        t "";
    #    }
    return \%font;
}


sub default_font_text {
    my $t = <<'EOFONT';
ASCII 032

0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

ASCII 033

11
11
11
11
11
11
11
11
11
11
00
11
11
00
00
00

ASCII 034

000110011
001100110
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000

ASCII 035

0011001100
0011001100
1111111111
1111111111
0011001100
0011001100
0011001100
0011001100
0011001100
1111111111
1111111111
0011001100
0011001100
0000000000
0000000000
0000000000

ASCII 036

00000000
00011000
01111110
11111111
11011011
11011000
11111110
01111111
00011011
11011011
11111111
01111110
00011000
00000000
00000000
00000000

ASCII 037

0000001
0110001
0110011
0000011
0000110
0000110
0001100
0001100
0011000
0011000
0110000
0110011
1100011
1100000
0000000
0000000

ASCII 038

000111000000
001111100000
011000110000
011000110000
001101100000
001111000000
011111000000
111011100110
110001110110
110000111110
111000111100
011111111110
001111100111
000000000000
000000000000
000000000000

ASCII 039

11
11
01
10
00
00
00
00
00
00
00
00
00
00
00
00

ASCII 040

0001
0011
0110
0110
0110
1100
1100
1100
1100
1100
1100
0110
0110
0110
0011
0001

ASCII 041

1000
1100
0110
0110
0110
0011
0011
0011
0011
0011
0011
0110
0110
0110
1100
1000

ASCII 042

0000000000
0000000000
0000110000
1100110011
0110110110
0011111100
1111111111
1111111111
0011111100
0110110110
1100110011
0000110000
0000000000
0000000000
0000000000
0000000000

ASCII 043

00000000
00000000
00000000
00011000
00011000
00011000
11111111
11111111
00011000
00011000
00011000
00000000
00000000
00000000
00000000
00000000

ASCII 044

00
00
00
00
00
00
00
00
00
00
00
11
11
01
10
00

ASCII 045

000000
000000
000000
000000
000000
000000
111111
111111
000000
000000
000000
000000
000000
000000
000000
000000

ASCII 046

00
00
00
00
00
00
00
00
00
00
00
11
11
00
00
00

ASCII 047

00000011
00000011
00000110
00000110
00001100
00001100
00011000
00011000
00110000
00110000
01100000
01100000
11000000
11000000
00000000
00000000

ASCII 048

0011111100
0111111110
1110000111
1100000011
1100000011
1100000011
1100000011
1100000011
1100000011
1100000011
1110000111
0111111110
0011111100
0000000000
0000000000
0000000000

ASCII 049

0011
0111
1111
1111
0011
0011
0011
0011
0011
0011
0011
0011
0011
0000
0000
0000

ASCII 050

001111100
011111110
111000111
110000011
110000011
000000111
000001110
000011100
000111000
001110000
011100000
111111111
111111111
000000000
000000000
000000000

ASCII 051

001111100
011111110
111000111
110000011
110000111
000111110
000111110
000000111
110000011
110000011
111000111
011111110
001111100
000000000
000000000
000000000

ASCII 052

0000001100
0000011100
0000111100
0001111100
0011101100
0111001100
1110001100
1100001100
1111111111
1111111111
0000001100
0000001100
0000001100
0000000000
0000000000
0000000000

ASCII 053

111111110
111111110
110000000
110000000
110111100
111111110
111000111
000000011
000000011
110000011
110000011
011111110
001111100
000000000
000000000
000000000

ASCII 054

001111100
011111110
111000111
110000000
110111100
111111110
111000111
110000011
110000011
110000011
111000111
011111110
001111100
000000000
000000000
000000000

ASCII 055

111111111
111111111
000000111
000000110
000001110
000001100
000011100
000011000
000111000
000110000
001110000
001100000
001100000
000000000
000000000
000000000

ASCII 056

0011111100
0111111110
0110000110
0110000110
0110000110
0011111100
0111111110
1110000111
1100000011
1100000011
1110000111
0111111110
0011111100
0000000000
0000000000
0000000000

ASCII 057

001111100
011111110
111000111
110000011
110000011
111000111
011111111
001111011
000000011
000000011
111000111
011111110
001111100
000000000
000000000
000000000

ASCII 058

00
00
00
11
11
00
00
11
11
00
00
00
00
00
00
00

ASCII 059

000
000
000
011
011
000
000
011
011
110
000
000
000
000
000
000

ASCII 060

00000011
00000110
00001100
00011000
00110000
01100000
11000000
01100000
00110000
00011000
00001100
00000110
00000011
00000000
00000000
00000000

ASCII 061

000000
000000
000000
000000
111111
111111
000000
000000
111111
111111
000000
000000
000000
000000
000000
000000

ASCII 062

11000000
01100000
00110000
00011000
00001100
00000110
00000011
00000110
00001100
00011000
00110000
01100000
11000000
00000000
00000000
00000000

ASCII 063

001111100
011111110
111000111
110000011
000000011
000000110
000001100
000011000
000110000
000110000
000000000
000110000
000110000
000000000
000000000
000000000

ASCII 064

000011110000
001111111100
011100001110
110000000011
110011110011
110111111011
110110011011
110111111011
110011101110
110000000000
011100000000
001111111100
000011111000
000000000000
000000000000
000000000000

ASCII 065

00001110000
00001110000
00011011000
00011011000
00110001100
00110001100
00110001100
01100000110
01111111110
01111111110
11000000011
11000000011
11000000011
00000000000
00000000000
00000000000

ASCII 066

1111111100
1111111110
1100000110
1100000110
1100000110
1111111100
1111111110
1100000111
1100000011
1100000011
1100000111
1111111110
1111111100
0000000000
0000000000
0000000000

ASCII 067

0001111100
0011111110
0111000111
0110000011
1100000000
1100000000
1100000000
1100000000
1100000000
0110000011
0111000111
0011111110
0001111100
0000000000
0000000000
0000000000

ASCII 068

11111111000
11111111100
11000001110
11000000111
11000000011
11000000011
11000000011
11000000011
11000000011
11000000111
11000001110
11111111100
11111111000
00000000000
00000000000
00000000000

ASCII 069

11111111
11111111
11000000
11000000
11000000
11111111
11111111
11000000
11000000
11000000
11000000
11111111
11111111
00000000
00000000
00000000

ASCII 070

11111111
11111111
11000000
11000000
11000000
11111110
11111110
11000000
11000000
11000000
11000000
11000000
11000000
00000000
00000000
00000000

ASCII 071

00011111100
00111111110
01110000111
11100000011
11000000000
11000000000
11000000000
11000011111
11000011111
11100000011
01110000111
00111111111
00011111011
00000000000
00000000000
00000000000

ASCII 072

110000011
110000011
110000011
110000011
110000011
111111111
111111111
110000011
110000011
110000011
110000011
110000011
110000011
000000000
000000000
000000000

ASCII 073

11
11
11
11
11
11
11
11
11
11
11
11
11
00
00
00

ASCII 074

0011
0011
0011
0011
0011
0011
0011
0011
0011
0011
0011
1111
1110
0000
0000
0000

ASCII 075

1100000011
1100000110
1100001100
1100011000
1100110000
1101100000
1111100000
1111100000
1110110000
1100011000
1100001100
1100000110
1100000011
0000000000
0000000000
0000000000

ASCII 076

110000000
110000000
110000000
110000000
110000000
110000000
110000000
110000000
110000000
110000000
110000000
111111111
111111111
000000000
000000000
000000000

ASCII 077

1110000000111
1110000000111
1111000001111
1111000001111
1111000001111
1101100011011
1101100011011
1101100011011
1100110110011
1100110110011
1100111110011
1100011100011
1100011100011
0000000000000
0000000000000
0000000000000

ASCII 078

11110000011
11110000011
11011000011
11011000011
11011100011
11001100011
11001110011
11000110011
11000111011
11000011011
11000011111
11000001111
11000001111
00000000000
00000000000
00000000000

ASCII 079

00011111000
00111111100
01110001110
01100000110
11000000011
11000000011
11000000011
11000000011
11000000011
01100000110
01110001110
00111111100
00011111000
00000000000
00000000000
00000000000

ASCII 080

111111100
111111110
110000111
110000011
110000011
110000111
111111110
111111100
110000000
110000000
110000000
110000000
110000000
000000000
000000000
000000000

ASCII 081

000011111000
001111111100
011100001110
011000000110
110000000011
110000000011
110000000011
110000000011
110000000011
011000000110
011100001110
001111111110
000111110111
000000000010
000000000000
000000000000

ASCII 082

111111100
111111110
110000111
110000011
110000011
110000110
111111110
111111111
110000111
110000011
110000011
110000011
110000011
000000000
000000000
000000000

ASCII 083

0011111100
0111111110
1110000110
1100000011
1100000000
1111111100
0111111110
0000000111
0000000011
1100000011
1110000111
0111111110
0011111100
0000000000
0000000000
0000000000

ASCII 084

1111111111
1111111111
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000000000
0000000000
0000000000

ASCII 085

1100000011
1100000011
1100000011
1100000011
1100000011
1100000011
1100000011
1100000011
1100000011
1100000011
1110000111
0111111110
0011111100
0000000000
0000000000
0000000000

ASCII 086

11000000011
11000000011
01100000110
01100000110
01100000110
00110001100
00110001100
00110001100
00011011000
00011011000
00011011000
00001110000
00001110000
00000000000
00000000000
00000000000

ASCII 087

1100000110000011
1100000110000011
0110001111000110
0110001111000110
0110001111000110
0011011001101100
0011011001101100
0011011001101100
0001111001111000
0001110000111000
0001110000111000
0000110000110000
0000110000110000
0000000000000000
0000000000000000
0000000000000000

ASCII 088

110000011
110000011
011000110
011000110
001101100
001101100
000111000
001101100
001101100
011000110
011000110
110000011
110000011
000000000
000000000
000000000

ASCII 089

1100000011
1100000011
0110000110
0110000110
0011001100
0011001100
0001111000
0001111000
0000110000
0000110000
0000110000
0000110000
0000110000
0000000000
0000000000
0000000000

ASCII 090

1111111111
1111111111
0000000011
0000000111
0000001110
0000011100
0000111000
0001110000
0011100000
0111000000
1110000000
1111111111
1111111111
0000000000
0000000000
0000000000

ASCII 091

111111
111111
110000
110000
110000
110000
110000
110000
110000
110000
110000
111111
111111
000000
000000
000000

ASCII 092

11000000
11000000
01100000
01100000
00110000
00110000
00011000
00011000
00001100
00001100
00000110
00000110
00000011
00000011
00000000
00000000

ASCII 093

111111
111111
000011
000011
000011
000011
000011
000011
000011
000011
000011
111111
111111
000000
000000
000000

ASCII 094

0000110000
0001111000
0011111100
0110110110
1100110011
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000110000
0000000000
0000000000
0000000000

ASCII 095

000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
111111111
111111111
000000000
000000000
000000000

ASCII 096

000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
000000000
111111111
111111111
000000000
000000000
000000000

ASCII 097

0000000
0000000
0000000
0111110
1111111
1100011
0000011
0111111
1111011
1100011
1100011
1111111
0111110
0000000
0000000
0000000

ASCII 098

11000000
11000000
11000000
11011100
11111110
11100111
11000011
11000011
11000011
11000011
11100111
11111110
11011100
00000000
00000000
00000000

ASCII 099

00000000
00000000
00000000
00111100
01111110
11100111
11000011
11000000
11000000
11000011
11100111
01111110
00111100
00000000
00000000
00000000

ASCII 100

00000011
00000011
00000011
00111011
01111111
11100111
11000011
11000011
11000011
11000011
11100111
01111111
00111011
00000000
00000000
00000000

ASCII 101

00000000
00000000
00000000
00111100
01111110
11100111
11000011
11111111
11111111
11000000
11100111
01111110
00111100
00000000
00000000
00000000

ASCII 102

00111
01111
01100
11111
11111
01100
01100
01100
01100
01100
01100
01100
01100
00000
00000
00000

ASCII 103

00000000
00000000
00000000
00111011
01111111
11100111
11000011
11000011
11000011
11000011
11100111
01111111
00111011
00000011
01111110
00111100

ASCII 104

11000000
11000000
11000000
11011110
11111111
11100011
11000011
11000011
11000011
11000011
11000011
11000011
11000011
00000000
00000000
00000000

ASCII 105

11
11
00
11
11
11
11
11
11
11
11
11
11
00
00
00

ASCII 106

0000
0000
0000
0011
0011
0000
0011
0011
0011
0011
0011
0011
0011
0011
1111
1110

ASCII 107

110000000
110000000
110000000
110000110
110001100
110011000
110110000
111100000
110110000
110011000
110001100
110000110
110000011
000000000
000000000
000000000

ASCII 108

11
11
11
11
11
11
11
11
11
11
11
11
11
00
00
00

ASCII 109

000000000000
000000000000
000000000000
110111101110
111111111111
111011110111
110001100011
110001100011
110001100011
110001100011
110001100011
110001100011
110001100011
000000000000
000000000000
000000000000

ASCII 110

0000000
0000000
0000000
1101110
1111111
1110011
1100011
1100011
1100011
1100011
1100011
1100011
1100011
0000000
0000000
0000000

ASCII 111

00000000
00000000
00000000
00111100
01111110
11100111
11000011
11000011
11000011
11000011
11100111
01111110
00111100
00000000
00000000
00000000

ASCII 112

00000000
00000000
00000000
11011100
11111110
11100111
11000011
11000011
11000011
11000011
11100111
11111110
11011100
11000000
11000000
11000000

ASCII 113

00000000
00000000
00000000
00111011
01111111
11100111
11000011
11000011
11000011
11000011
11100111
01111111
00111011
00000011
00000011
00000011

ASCII 114

00000
00000
00000
11011
11111
11100
11000
11000
11000
11000
11000
11000
11000
00000
00000
00000

ASCII 115

00000000
00000000
00000000
01111110
11111111
11000011
11000000
11111110
01111111
00000011
11000011
11111111
01111110
00000000
00000000
00000000

ASCII 116

001100
001100
001100
111111
111111
001100
001100
001100
001100
001100
001100
001111
000111
000000
000000
000000

ASCII 117

00000000
00000000
00000000
11000011
11000011
11000011
11000011
11000011
11000011
11000011
11000111
11111111
01111011
00000000
00000000
00000000

ASCII 118

000000000
000000000
000000000
110000011
110000011
011000110
011000110
011000110
001101100
001101100
001101100
000111000
000111000
000000000
000000000
000000000

ASCII 119

000000000000000
000000000000000
000000000000000
110000010000011
110000010000011
011000111000110
011000111000110
011000111000110
001101101101100
001101101101100
001101101101100
000111000111000
000111000111000
000000000000000
000000000000000
000000000000000

ASCII 120

0000000
0000000
0000000
1100011
1100011
0110110
0110110
0011100
0011100
0110110
0110110
1100011
1100011
0000000
0000000
0000000

ASCII 121

00000000000
00000000000
00000000000
11000000011
11000000011
01100000110
01100000110
00110001100
00110001100
00011011000
00011011000
00001110000
00001110000
00001100000
01111100000
01111000000

ASCII 122

00000000
00000000
00000000
11111111
11111111
00000011
00000110
00001100
00011000
00110000
01100000
11111111
11111111
00000000
00000000
00000000

ASCII 123

000011
000110
001100
001100
001100
011000
110000
011000
001100
001100
001100
000110
000011
000000
000000
000000

ASCII 124

11
11
11
11
11
11
00
11
11
11
11
11
11
00
00
00

ASCII 125

110000
011000
001100
001100
001100
000110
000011
000110
001100
001100
001100
011000
110000
000000
000000
000000

ASCII 126

0000000000000000
0110000000000000
0111000000001110
0011100001111100
0001111111111000
0000111111100000
0000111111100000
0000111110000000
0000111110000000
0001110011100011
0001110001111110
0001100000111000
0011100000111100
0011000000101100
0010000001100000
0000000001000000
EOFONT
    return $t;
}

1; # <-- return true